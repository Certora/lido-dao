--- ../contracts/0.8.9/StakingRouter.sol	2023-03-26 11:18:15.138581500 +0300
+++ 	2023-03-26 11:36:31.079961400 +0300
@@ -4,18 +4,18 @@
 /* See contracts/COMPILERS.md */
 pragma solidity 0.8.9;
 
-import {AccessControlEnumerable} from "./utils/access/AccessControlEnumerable.sol";
+import {AccessControlEnumerable} from "../../contracts/0.8.9/utils/access/AccessControlEnumerable.sol";
 
-import {IStakingModule} from "./interfaces/IStakingModule.sol";
+import {IStakingModule} from "../../contracts/0.8.9/interfaces/IStakingModule.sol";
 
-import {Math256} from "../common/lib/Math256.sol";
-import {UnstructuredStorage} from "./lib/UnstructuredStorage.sol";
-import {MinFirstAllocationStrategy} from "../common/lib/MinFirstAllocationStrategy.sol";
+import {Math256} from "../../contracts/common/lib/Math256.sol";
+import {UnstructuredStorage} from "../../contracts/0.8.9/lib/UnstructuredStorage.sol";
+import {MinFirstAllocationStrategy} from "../../contracts/common/lib/MinFirstAllocationStrategy.sol";
 
-import {BeaconChainDepositor} from "./BeaconChainDepositor.sol";
-import {Versioned} from "./utils/Versioned.sol";
+import {BeaconChainDepositorHarness} from "../helpers/BeaconChainDepositor.sol";
+import {Versioned} from "../../contracts/0.8.9/utils/Versioned.sol";
 
-contract StakingRouter is AccessControlEnumerable, BeaconChainDepositor, Versioned {
+contract StakingRouter is AccessControlEnumerable, BeaconChainDepositorHarness, Versioned {
     using UnstructuredStorage for bytes32;
 
     /// @dev events
@@ -126,7 +126,7 @@
     uint256 public constant MAX_STAKING_MODULES_COUNT = 32;
     uint256 public constant MAX_STAKING_MODULE_NAME_LENGTH = 32;
 
-    constructor(address _depositContract) BeaconChainDepositor(_depositContract) {}
+    constructor(address _depositContract) BeaconChainDepositorHarness(_depositContract) {}
 
     /**
      * @dev proxy initialization
@@ -134,7 +134,7 @@
      * @param _lido Lido address
      * @param _withdrawalCredentials Lido withdrawal vault contract address
      */
-    function initialize(address _admin, address _lido, bytes32 _withdrawalCredentials) external {
+    function initialize(address _admin, address _lido, bytes32 _withdrawalCredentials) public {
         if (_admin == address(0)) revert ZeroAddress("_admin");
         if (_lido == address(0)) revert ZeroAddress("_lido");
 
@@ -470,7 +470,7 @@
         bool _triggerUpdateFinish,
         ValidatorsCountsCorrection memory _correction
     )
-        external
+        public virtual
         onlyRole(UNSAFE_SET_EXITED_VALIDATORS_ROLE)
     {
         StakingModule storage stakingModule = _getStakingModuleById(_stakingModuleId);
@@ -1014,6 +1014,7 @@
                     stakingModuleFees[rewardedStakingModulesCount] = stakingModuleFee;
                 }
                 // else keep stakingModuleFees[rewardedStakingModulesCount] = 0, but increase totalFee
+                else {stakingModuleFees[rewardedStakingModulesCount] = 0;}
 
                 totalFee += (uint96((stakingModuleValidatorsShare * stakingModulesCache[i].treasuryFee) / TOTAL_BASIS_POINTS) + stakingModuleFee);
 
@@ -1030,14 +1031,16 @@
         if (totalFee >= precisionPoints) revert ValueOver100Percent("totalFee");
 
         /// @dev shrink arrays
-        if (rewardedStakingModulesCount < stakingModulesCount) {
+        /// @notice Certora : restrict rewarded modules count to avoid assembly block.
+        require (rewardedStakingModulesCount == stakingModulesCount); /* {
             uint256 trim = stakingModulesCount - rewardedStakingModulesCount;
+            uint256 trimmed_length = stakingModuleIds.length-trim;
             assembly {
-                mstore(stakingModuleIds, sub(mload(stakingModuleIds), trim))
-                mstore(recipients, sub(mload(recipients), trim))
-                mstore(stakingModuleFees, sub(mload(stakingModuleFees), trim))
-            }
+                mstore(stakingModuleIds, trimmed_length)
+                mstore(recipients, trimmed_length)
+                mstore(stakingModuleFees, trimmed_length)
         }
+        }*/
     }
 
     /// @notice Helper for Lido contract (DEPRECATED)
--- ../contracts/0.8.9/BeaconChainDepositor.sol	2023-03-14 12:09:21.827860300 +0200
+++ 	2023-03-26 11:36:31.079961400 +0300
@@ -4,7 +4,7 @@
 // See contracts/COMPILERS.md
 pragma solidity 0.8.9;
 
-import {MemUtils} from "../common/lib/MemUtils.sol";
+import {MemUtils} from "../../contracts/common/lib/MemUtils.sol";
 
 interface IDepositContract {
     function get_deposit_root() external view returns (bytes32 rootHash);
@@ -43,7 +43,8 @@
         bytes memory _withdrawalCredentials,
         bytes memory _publicKeysBatch,
         bytes memory _signaturesBatch
-    ) internal {
+    ) internal virtual {
+        /*
         if (_publicKeysBatch.length != PUBLIC_KEY_LENGTH * _keysCount) {
             revert InvalidPublicKeysBatchLength(_publicKeysBatch.length, PUBLIC_KEY_LENGTH * _keysCount);
         }
@@ -66,6 +67,7 @@
                 ++i;
             }
         }
+        */
     }
 
     /// @dev computes the deposit_root_hash required by official Beacon Deposit contract
--- ../contracts/0.4.24/nos/NodeOperatorsRegistry.sol	2023-03-26 11:18:13.568632600 +0300
+++ 	2023-03-26 11:36:31.079961400 +0300
@@ -9,13 +9,13 @@
 import {SafeMath64} from "@aragon/os/contracts/lib/math/SafeMath64.sol";
 import {UnstructuredStorage} from "@aragon/os/contracts/common/UnstructuredStorage.sol";
 
-import {Math256} from "../../common/lib/Math256.sol";
-import {MinFirstAllocationStrategy} from "../../common/lib/MinFirstAllocationStrategy.sol";
-import {ILidoLocator} from "../../common/interfaces/ILidoLocator.sol";
-import {IBurner} from "../../common/interfaces/IBurner.sol";
-import {SigningKeys} from "../lib/SigningKeys.sol";
-import {Packed64x4} from "../lib/Packed64x4.sol";
-import {Versioned} from "../utils/Versioned.sol";
+import {Math256} from "../../contracts/common/lib/Math256.sol";
+import {MinFirstAllocationStrategy} from "../../contracts/common/lib/MinFirstAllocationStrategy.sol";
+import {ILidoLocator} from "../../contracts/common/interfaces/ILidoLocator.sol";
+import {IBurner} from "../../contracts/common/interfaces/IBurner.sol";
+import {SigningKeys} from "../../contracts/0.4.24/lib/SigningKeys.sol";
+import {Packed64x4} from "../../contracts/0.4.24/lib/Packed64x4.sol";
+import {Versioned} from "../../contracts/0.4.24/utils/Versioned.sol";
 
 interface IStETH {
     function sharesOf(address _account) external view returns (uint256);
@@ -853,7 +853,7 @@
         uint256[] memory _nodeOperatorIds,
         uint256[] memory _activeKeyCountsAfterAllocation
     ) internal returns (bytes memory pubkeys, bytes memory signatures) {
-        (pubkeys, signatures) = SigningKeys.initKeysSigsBuf(_keysCountToLoad);
+        //(pubkeys, signatures) = SigningKeys.initKeysSigsBuf(_keysCountToLoad);
 
         uint256 loadedKeysCount = 0;
         uint64 depositedSigningKeysCountBefore;
@@ -869,9 +869,9 @@
             keysCount = depositedSigningKeysCountAfter.sub(depositedSigningKeysCountBefore);
             if (keysCount == 0) continue;
 
-            SIGNING_KEYS_MAPPING_NAME.loadKeysSigs(
-                _nodeOperatorIds[i], depositedSigningKeysCountBefore, keysCount, pubkeys, signatures, loadedKeysCount
-            );
+            //SIGNING_KEYS_MAPPING_NAME.loadKeysSigs(
+            //    _nodeOperatorIds[i], depositedSigningKeysCountBefore, keysCount, pubkeys, signatures, loadedKeysCount
+            //);
             loadedKeysCount += keysCount;
 
             emit DepositedSigningKeysCountChanged(_nodeOperatorIds[i], depositedSigningKeysCountAfter);
@@ -1120,23 +1120,26 @@
         view
         returns (bytes key, bytes depositSignature, bool used)
     {
+        /*
         bool[] memory keyUses;
         (key, depositSignature, keyUses) = getSigningKeys(_nodeOperatorId, _index, 1);
         used = keyUses[0];
+        */
     }
 
     /// @notice Returns n signing keys of the node operator #`_nodeOperatorId`
     /// @param _nodeOperatorId Node Operator id
-    /// @param _offset Offset of the key, starting with 0
+    /// @param offset Offset of the key, starting with 0
     /// @param _limit Number of keys to return
     /// @return pubkeys Keys concatenated into the bytes batch
     /// @return signatures Signatures concatenated into the bytes batch needed for a deposit_contract.deposit call
     /// @return used Array of flags indicated if the key was used in the staking
-    function getSigningKeys(uint256 _nodeOperatorId, uint256 _offset, uint256 _limit)
+    function getSigningKeys(uint256 _nodeOperatorId, uint256 offset, uint256 _limit)
         public
         view
         returns (bytes memory pubkeys, bytes memory signatures, bool[] memory used)
     {
+        /*
         _onlyExistedNodeOperator(_nodeOperatorId);
 
         Packed64x4.Packed memory signingKeysStats = _loadOperatorSigningKeysStats(_nodeOperatorId);
@@ -1150,6 +1153,7 @@
         for (uint256 i; i < _limit; ++i) {
             used[i] = (_offset + i) < depositedSigningKeysCount;
         }
+        */
     }
 
     /// @notice Returns the type of the staking module
@@ -1158,7 +1162,7 @@
     }
 
     function getStakingModuleSummary()
-        external
+        public
         view
         returns (uint256 totalExitedValidators, uint256 totalDepositedValidators, uint256 depositableValidatorsCount)
     {
@@ -1169,7 +1173,7 @@
     }
 
     function getNodeOperatorSummary(uint256 _nodeOperatorId)
-        external
+        public
         view
         returns (
             bool isTargetLimitActive,
